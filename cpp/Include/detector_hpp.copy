/*detector.hpp*/
#ifndef DETECTOR_HPP
#define DETECTOR_HPP

#include<cmath>

#include "xraylib.h"

class Channel
{
private:
	double _ev_offset;
	double _ev_gain;
	int _n_channels;
public:
	Channel();
	Channel(double ev_offset_, double ev_gain_, int n_channels_);
	~channel();
	Channel & operator=(const Channel & ch);
	const double & ev_offset;
	const double & ev_gain;
	const int & n_channels;
	int energy_to_channel(ev) const;
	void bin(const vector<double> & y_raw, vector<double> & y_binned);
};

class Response
{
private:
	double _noise;
	double _fano;
	double _gamma;
	double _fs;
	double _ft;
	double _gain;
public:
	Response();
	Response(double noise_ = 100,
		double fano_ = 0.114,
		double gamma_ = 2.5,
		double fs_ = 0.03,
		double ft_ = 0.02,
		double gain_ = 0);
	~Response();
	Response & operator=(const Response & rsp);
	const double & noise;
	const double & fano;
	const double & gamma;
	const double & fs;
	const double & ft;
	const double & gain;
	
	double FWHM(double ev)
	{
		return 2.3548*std::sqrt((noise/2.3548)**2+3.58*fano*ev);
	}
};

		
class Window
{
private:
	int _material;
	double _thickness;
	double _density;
public:
	Window();
	Window(int material_ = 4,
	double thickness_ = 24e-4,
	double density_ = 1);
	~Window();
	Window & operator=(const Window & w);
	const int & material;
	const double & thickness;
	const double & density;
	double transmission(double ev) const
	{
		double _mac = CS_Total_CP(material, ev/1000.);
		return np.exp(-_mac*density*thickness);
	}

};
		
class Detector
{
	def __init__(self, channel = channel(), response = response(), omega=solid_angle(), window = window()):
private:
	Channel channel;
	Response response;
	response.gain = channel.gain
		self.omega = omega
		self.window = window
};

#endif